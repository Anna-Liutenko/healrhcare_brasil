# Требования к функционалу публикации страниц — 2025-10-12

## Уточнённая формулировка задачи

### Основная цель
Связать визуальный редактор с публичным сайтом, чтобы администратор мог создавать, редактировать и публиковать страницы, которые затем доступны пользователям по прямым URL.

---

## Детальные требования

### 1. Публикация и редактирование опубликованных страниц

**Требование:**
- Администратор создаёт страницу в визуальном редакторе, заполняет название, slug, собирает контент из блоков.
- После нажатия кнопки **"Опубликовать"** страница получает статус `published` и становится доступна на публичном сайте по URL `example-site.com/{slug}`.
- **Важно:** После публикации администратор должен иметь возможность **редактировать уже опубликованную страницу**:
  - Открыть страницу в редакторе.
  - Изменить контент (добавить/удалить блоки, отредактировать текст, изображения).
  - Сохранить изменения.
  - Повторно опубликовать (или автоматически обновить публичную версию при сохранении).

**Технически это означает:**
- Страница имеет lifecycle: `draft` → `published` → может вернуться в редактируемое состояние (draft для изменений) или обновляться прямо в статусе `published`.
- При редактировании опубликованной страницы:
  - Option A (рекомендуемый): изменения сохраняются, и при следующей публикации (или автоматическом сохранении) обновляется публичная версия.
  - Option B (advanced): draft/staging копия для редактирования, и explicit "Re-publish" action.
  - **Выбираем Option A** для простоты: publish устанавливает статус `published`, редактирование сохраняет изменения, повторная публикация (или кнопка "Обновить опубликованную версию") рендерит новую версию HTML.

**Workflow:**
1. Создать страницу → собрать контент → нажать "Опубликовать" → страница доступна публично.
2. Открыть опубликованную страницу в редакторе → изменить блоки → сохранить → нажать "Обновить опубликованную версию" (или повторная публикация) → публичная версия обновляется.

---

### 2. Статичный HTML рендеринг (идентичный preview редактора)

**Требование:**
- Публичный сайт должен отдавать пользователю **статичный HTML**, который полностью совпадает с тем, что администратор видит в preview редактора.
- Этот HTML — тот же самый, который можно скачать кнопкой **"Скачать HTML"** из редактора.
- **Важно:** HTML должен быть **заранее сгенерирован** (pre-rendered) при публикации и сохранён в базе данных, чтобы:
  - Публичный сайт отдавал готовый HTML без повторного рендеринга на каждом запросе (performance).
  - Гарантировать, что опубликованная версия не изменится из-за багов/изменений в логике рендеринга (immutability snapshot).
  - Позволять откат к предыдущим версиям (если в будущем потребуется версионирование).

**Технически это означает:**
- При публикации (или обновлении публикации):
  - Backend вызывает функцию рендеринга (аналогично "Скачать HTML" в редакторе).
  - Генерирует полный HTML страницы (включая header, footer, блоки, стили из `editor-preview.css`/`editor-public.css`).
  - Сохраняет HTML в БД в поле `pages.rendered_html` (LONGTEXT).
- Публичный контроллер `PublicPageController::show($slug)`:
  - Находит страницу по slug.
  - Проверяет статус: если `published` и `rendered_html` не null → отдаёт `rendered_html` с `Content-Type: text/html`.
  - Fallback (если rendered_html отсутствует): выполнить runtime рендеринг (но это не должно происходить в production после публикации).

**Преимущества подхода:**
- Быстрая отдача контента (нет повторного парсинга/рендеринга).
- Стабильность: опубликованная версия неизменна (если не нажата кнопка "Обновить").
- Соответствие preview: администратор видит в редакторе ровно то, что увидит пользователь.

---

### 3. Управление меню: галочка "Показать в меню" + пользовательское название пункта меню

**Требование:**
- В настройках страницы (правая панель редактора) должна быть галочка **"Показать в меню"** (`show_in_menu`).
- Эта галочка активна **только для опубликованных страниц** (для draft/archived страниц галочка недоступна или автоматически снимается).
- **Под галочкой** должно быть поле ввода **"Название в меню"** (`menu_title`), где администратор может написать **кастомное название пункта меню** (отличное от `page.title` и `page.slug`).
  - Пример: page.title = "О здравоохранении в Бразилии", page.slug = "healthcare-brazil", menu_title = "О нас".
  - Если поле `menu_title` пустое — использовать `page.title` как fallback.

**Технически это означает:**
- БД:
  - Таблица `pages` уже имеет колонку `show_in_menu` (TINYINT/BOOLEAN).
  - Добавить колонку `menu_title` VARCHAR(255) NULL (пользовательское название для пункта меню).
- Frontend (`editor.js`):
  - В секции настроек добавить:
    - Checkbox "Показать в меню" (уже существует как `pageSettings.showInMenu`).
    - Input text "Название в меню" (новое поле `pageSettings.menuTitle`), которое отображается только если галочка активна.
  - При сохранении страницы отправлять `menu_title` в API.
  - Логика: галочка "Показать в меню" доступна только если `pageData.status === 'published'` (это уже реализовано в коде: `show_in_menu: (this.pageSettings.showInMenu && (this.pageData.status === 'published')) ? 1 : 0`).
- Backend:
  - `MenuController::getPublicMenu()` (уже существует) при формировании меню выбирает `menu_title` вместо `title`:
    ```sql
    SELECT id, COALESCE(menu_title, title) AS label, slug, menu_position
    FROM pages
    WHERE status = 'published' AND show_in_menu = 1
    ORDER BY menu_position ASC, id ASC
    ```
  - API endpoint сохранения страницы принимает `menu_title` и сохраняет в БД.

**Workflow:**
1. Администратор создаёт страницу, публикует её.
2. Открывает настройки страницы, ставит галочку "Показать в меню".
3. В поле "Название в меню" пишет "О нас" (вместо длинного page.title).
4. Сохраняет.
5. Публичное меню сайта отображает пункт "О нас" с URL `/healthcare-brazil`.

---

## Итоговый технический контракт

### Inputs (что предоставляет администратор):
- **Страница:** title, slug (уникальный), blocks (массив блоков), settings (metadata, show_in_menu, menu_title).
- **Действия:** "Сохранить" (без публикации), "Опубликовать" (установить статус published + рендер HTML), "Обновить опубликованную версию" (ре-публикация).

### Outputs (что получает пользователь):
- **Публичная страница:** доступна по URL `example-site.com/{slug}`.
- **HTML:** статичный, сгенерированный при публикации, сохранённый в `pages.rendered_html`.
- **Меню:** если `show_in_menu=1` и страница опубликована, пункт появляется в меню с названием `menu_title` (или `title` как fallback).

### Lifecycle страницы:
1. **Draft** → создание, редактирование, не видна публично.
2. **Публикация** → клик "Опубликовать" → статус `published`, генерация `rendered_html`, установка `published_at` timestamp.
3. **Редактирование опубликованной** → изменение контента → сохранение (статус остаётся `published`, но `rendered_html` не обновляется автоматически) → клик "Обновить опубликованную версию" → регенерация `rendered_html`.
4. **Снятие с публикации** (optional) → статус `draft` или `archived` → страница исчезает с публичного сайта и из меню.

---

## Отличия от первоначального плана

**Что изменилось:**
1. **Редактирование опубликованных страниц** — добавлено явное требование (не было в первоначальном плане).
2. **Статичный HTML (rendered_html)** — уточнено, что HTML должен быть pre-rendered и сохранён в БД (в первоначальном плане предлагался hybrid подход, теперь акцент на обязательное хранение rendered_html).
3. **Пользовательское название в меню (`menu_title`)** — новое поле, не упомянутое в первоначальном плане. Требуется добавить колонку в БД и UI элемент в редакторе.

**Что остаётся из первоначального плана:**
- Использование существующих use-cases (`PublishPage`, `RenderStaticTemplate`, `GetPageWithBlocks`).
- API endpoint `PUT /api/pages/:id/publish`.
- Публичный контроллер `PublicPageController::show($slug)`.
- Валидация slug, уникальность, генерация из title.
- E2E тесты создания → публикации → проверки публичного URL.

---

## Следующие шаги (приоритезированный план реализации)

### Фаза 1: DB Schema & Migrations
1. Добавить колонку `rendered_html` LONGTEXT NULL в таблицу `pages`.
2. Добавить колонку `menu_title` VARCHAR(255) NULL в таблицу `pages`.
3. Добавить уникальный индекс на `pages.slug` (если ещё не существует).
4. SQL миграция:
   ```sql
   ALTER TABLE pages 
     ADD COLUMN rendered_html LONGTEXT NULL COMMENT 'Pre-rendered static HTML at publish time',
     ADD COLUMN menu_title VARCHAR(255) NULL COMMENT 'Custom menu item label (overrides title)',
     ADD UNIQUE INDEX ux_pages_slug (slug);
   ```

### Фаза 2: Backend — Publish Flow with Static HTML Rendering
1. Обновить `Application\UseCase\PublishPage`:
   - После `$page->publish()` вызвать рендеринг HTML (использовать логику из `RenderStaticTemplate` или `PublicPageController::renderPage`).
   - Сохранить результат в `$page->setRenderedHtml($html)`.
   - Сохранить `$page->setPublishedAt(new DateTime())` если ещё не установлен.
   - `$pageRepository->save($page)`.
2. Обновить `Infrastructure\Repository\MySQLPageRepository`:
   - Добавить поддержку чтения/записи `rendered_html` и `menu_title` в методах `save()`, `hydrate()`.
3. Обновить `Presentation\Controller\PublicPageController::show($slug)`:
   - Если `$page->getRenderedHtml()` не null → `echo $page->getRenderedHtml(); exit;`.
   - Иначе fallback runtime render (для draft/preview mode).
4. Обновить `Presentation\Controller\MenuController::getPublicMenu()`:
   - SELECT использует `COALESCE(menu_title, title) AS label`.

### Фаза 3: Frontend — UI для menu_title и кнопка Re-publish
1. `frontend/editor.js`:
   - Добавить в `pageSettings` поле `menuTitle` (string).
   - В HTML шаблоне настроек добавить input для "Название в меню" (отображается только если `pageSettings.showInMenu === true`).
   - При сохранении передавать `menu_title` в API payload.
   - Добавить кнопку "Обновить опубликованную версию" (или сделать "Опубликовать" идемпотентной — повторный вызов обновляет rendered_html).
2. `frontend/api-client.js`:
   - Убедиться, что `savePage()` отправляет `menu_title`.
   - `publishPage()` вызывает PUT `/api/pages/:id/publish`.

### Фаза 4: Testing
1. Unit tests:
   - `PublishPage` use-case: проверить, что rendered_html сохраняется.
   - `MySQLPageRepository`: чтение/запись rendered_html и menu_title.
2. Integration/E2E:
   - Создать страницу → опубликовать → проверить публичный URL возвращает rendered_html.
   - Изменить опубликованную страницу → ре-публиковать → проверить обновление rendered_html.
   - Установить menu_title → проверить меню содержит custom название.
   - Снять галочку "Показать в меню" → проверить страница исчезла из меню.

### Фаза 5: Deployment & Documentation
1. Развернуть DB миграцию.
2. Развернуть backend код.
3. Развернуть frontend код.
4. Smoke test: создать → опубликовать → проверить публичный URL.
5. Обновить документацию (API_ENDPOINTS_CHEATSHEET.md, добавить описание `menu_title`, `rendered_html`).

---

## Резюме требований (краткая формулировка для разработчика)

**Задача:** Интегрировать визуальный редактор с публичным сайтом.

**Ключевые фичи:**
1. **Публикация страниц:** кнопка "Опубликовать" устанавливает статус `published`, генерирует статичный HTML и сохраняет его в БД (`rendered_html`). Публичный сайт отдаёт этот HTML по URL `/{slug}`.
2. **Редактирование опубликованных страниц:** администратор может изменять уже опубликованную страницу, сохранять изменения и ре-публиковать (обновлять `rendered_html`).
3. **Управление меню:** галочка "Показать в меню" (только для опубликованных страниц) + поле "Название в меню" (`menu_title`) для кастомного названия пункта меню (вместо `page.title`).

**Технические требования:**
- DB: добавить колонки `rendered_html` (LONGTEXT), `menu_title` (VARCHAR(255)), уникальный индекс на `slug`.
- Backend: use-case PublishPage генерирует и сохраняет `rendered_html`, PublicPageController отдаёт его, MenuController использует `menu_title`.
- Frontend: UI для `menu_title`, кнопка Re-publish, сохранение `menu_title` в API.
- Tests: E2E публикация → изменение → ре-публикация, проверка меню с `menu_title`.

---

Дата создания: 2025-10-12  
Автор уточнений: администратор проекта  
Статус: утверждено для реализации
